# Test percentile_agg and approx_percentile functions

# Create test table with sample data
statement ok
CREATE TABLE percentile_test (
    project_id INTEGER,
    value DOUBLE
)

# Insert test data - normal distribution-like values
statement ok
INSERT INTO percentile_test VALUES
(1, 10.5), (1, 12.3), (1, 15.7), (1, 18.2), (1, 20.1),
(1, 22.5), (1, 25.8), (1, 28.3), (1, 30.9), (1, 35.2),
(1, 38.7), (1, 42.1), (1, 45.6), (1, 48.9), (1, 52.3),
(1, 55.7), (1, 58.2), (1, 62.5), (1, 65.8), (1, 70.1),
(1, 73.4), (1, 76.8), (1, 80.2), (1, 83.5), (1, 87.9),
(1, 90.3), (1, 93.7), (1, 97.1), (1, 98.5), (1, 99.9)

# Test percentile_agg aggregation
query B
SELECT percentile_agg(value) IS NOT NULL as has_digest
FROM percentile_test
WHERE project_id = 1
----
true

# Test approx_percentile with median (50th percentile)
# Note: T-Digest is an approximation algorithm, so we check a range
query B
SELECT approx_percentile(0.5, percentile_agg(value)) BETWEEN 52 AND 56 as median_in_range
FROM percentile_test
WHERE project_id = 1
----
true

# Test multiple percentiles
# Note: T-Digest is approximate, check ranges
query B
SELECT 
    approx_percentile(0.25, percentile_agg(value)) BETWEEN 27 AND 31 AND
    approx_percentile(0.5, percentile_agg(value)) BETWEEN 52 AND 56 AND
    approx_percentile(0.75, percentile_agg(value)) BETWEEN 77 AND 81
    AS all_percentiles_in_range
FROM percentile_test
WHERE project_id = 1
----
true

# Test edge cases - 0th and 100th percentiles
query RR
SELECT 
    ROUND(approx_percentile(0.0, percentile_agg(value)), 1) as min_val,
    ROUND(approx_percentile(1.0, percentile_agg(value)), 1) as max_val
FROM percentile_test
WHERE project_id = 1
----
10.5 99.9

# Test with GROUP BY - add more projects for proper grouping tests
statement ok
INSERT INTO percentile_test VALUES
(2, 5.0), (2, 10.0), (2, 15.0), (2, 20.0), (2, 25.0),
(3, 100.0), (3, 200.0), (3, 300.0), (3, 400.0), (3, 500.0)

# Test GROUP BY with percentile calculations per project
query IB
SELECT 
    project_id,
    approx_percentile(0.5, percentile_agg(value)) BETWEEN 
        CASE project_id 
            WHEN 1 THEN 52 
            WHEN 2 THEN 14
            WHEN 3 THEN 290
        END AND 
        CASE project_id
            WHEN 1 THEN 56
            WHEN 2 THEN 16  
            WHEN 3 THEN 310
        END as median_in_range
FROM percentile_test
WHERE project_id IN (1, 2, 3)
GROUP BY project_id
ORDER BY project_id
----
1 true
2 true
3 true

# Test GROUP BY with multiple percentiles
query IBBB
SELECT 
    project_id,
    approx_percentile(0.25, percentile_agg(value)) BETWEEN
        CASE project_id WHEN 1 THEN 27 WHEN 2 THEN 9 WHEN 3 THEN 190 END AND
        CASE project_id WHEN 1 THEN 31 WHEN 2 THEN 11 WHEN 3 THEN 210 END as p25_ok,
    approx_percentile(0.75, percentile_agg(value)) BETWEEN
        CASE project_id WHEN 1 THEN 77 WHEN 2 THEN 19 WHEN 3 THEN 390 END AND
        CASE project_id WHEN 1 THEN 81 WHEN 2 THEN 21 WHEN 3 THEN 410 END as p75_ok,
    approx_percentile(0.95, percentile_agg(value)) BETWEEN
        CASE project_id WHEN 1 THEN 95 WHEN 2 THEN 23 WHEN 3 THEN 470 END AND
        CASE project_id WHEN 1 THEN 100 WHEN 2 THEN 26 WHEN 3 THEN 510 END as p95_ok
FROM percentile_test
WHERE project_id IN (1, 2, 3)
GROUP BY project_id
ORDER BY project_id
----
1 true true true
2 true true true
3 true true true

# Test GROUP BY with filters on aggregated percentiles
query I
SELECT project_id
FROM (
    SELECT 
        project_id,
        approx_percentile(0.5, percentile_agg(value)) as median
    FROM percentile_test
    WHERE project_id IN (1, 2, 3)
    GROUP BY project_id
) t
WHERE median > 50
ORDER BY project_id
----
1
3

# Test with NULL values
statement ok
INSERT INTO percentile_test VALUES (2, NULL), (2, 50.0), (2, NULL), (2, 60.0), (2, 70.0)

# After adding values, project_id=2 has: 5, 10, 15, 20, 25, 50, 60, 70
# Median should be (20+25)/2 = 22.5
query B
SELECT approx_percentile(0.5, percentile_agg(value)) BETWEEN 20 AND 25 as median_in_range
FROM percentile_test
WHERE project_id = 2
----
true

# Test error handling - invalid percentile
statement error
SELECT approx_percentile(1.5, percentile_agg(value))
FROM percentile_test
WHERE project_id = 1

statement error
SELECT approx_percentile(-0.1, percentile_agg(value))
FROM percentile_test
WHERE project_id = 1

# Clean up
statement ok
DROP TABLE percentile_test

# ============================================
# Test percentile with time-series data (from the other file)
# ============================================

# Create test table for time-series data
statement ok
CREATE TABLE test_spans (
    project_id VARCHAR,
    timestamp TIMESTAMP WITH TIME ZONE,
    duration BIGINT
)

# Insert test data with durations in nanoseconds
statement ok
INSERT INTO test_spans VALUES
('test-project', '2025-08-10T15:00:00Z', 50000000),   -- 50ms
('test-project', '2025-08-10T15:30:00Z', 75000000),   -- 75ms
('test-project', '2025-08-10T15:45:00Z', 90000000),   -- 90ms
('test-project', '2025-08-10T16:00:00Z', 100000000),  -- 100ms
('test-project', '2025-08-10T16:30:00Z', 150000000),  -- 150ms
('test-project', '2025-08-10T16:45:00Z', 200000000)   -- 200ms

# Test 1: Simple percentile calculation with unit conversion
query B
SELECT approx_percentile(0.5, percentile_agg(duration)) / 1000000.0 BETWEEN 85 AND 105 as median_in_range
FROM test_spans
WHERE project_id = 'test-project'
----
true

# Test 2: Multiple percentiles in columns for time-series data
# Since T-Digest is approximate, we test that values are within reasonable ranges
query B
SELECT 
    -- P50 should be between 85-105 (actual: ~95)
    approx_percentile(0.50, percentile_agg(duration)) / 1000000.0 BETWEEN 85 AND 105 AND
    -- P75 should be between 120-180 (actual: ~137.5)
    approx_percentile(0.75, percentile_agg(duration)) / 1000000.0 BETWEEN 120 AND 180 AND
    -- P90 should be between 150-200 (actual: ~175)
    approx_percentile(0.90, percentile_agg(duration)) / 1000000.0 BETWEEN 150 AND 200 AND
    -- P95 should be between 170-200 (actual: ~187.5)
    approx_percentile(0.95, percentile_agg(duration)) / 1000000.0 BETWEEN 170 AND 200
    AS all_percentiles_in_range
FROM test_spans
WHERE project_id = 'test-project'
----
true

# Test 3: Array construction with ARRAY function
query B
SELECT ARRAY[1.0, 2.0, 3.0] IS NOT NULL as has_array
FROM test_spans
WHERE project_id = 'test-project'
LIMIT 1
----
true

# Test 4: array_element function with literal array
query R
SELECT array_element(ARRAY[10.5, 20.5, 30.5], 2) as second_element
FROM test_spans
WHERE project_id = 'test-project'
LIMIT 1
----
20.5

# Test 5: array_element with string array
query T
SELECT array_element(ARRAY['p50', 'p75', 'p90', 'p95'], 3) as third_quantile
FROM test_spans
WHERE project_id = 'test-project'
LIMIT 1
----
p90

# Test 6: Percentiles grouped by time buckets using time_bucket function
query TBB
SELECT 
    to_char(time_bucket('1 hour', timestamp), 'YYYY-MM-DD HH24:MI:SS') as hour,
    approx_percentile(0.5, percentile_agg(duration)) / 1000000.0 BETWEEN
        CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 65 ELSE 140 END AND
        CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 85 ELSE 160 END as p50_ok,
    approx_percentile(0.95, percentile_agg(duration)) / 1000000.0 BETWEEN
        CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 85 ELSE 190 END AND
        CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 95 ELSE 210 END as p95_ok
FROM test_spans
WHERE project_id = 'test-project'
GROUP BY time_bucket('1 hour', timestamp)
ORDER BY hour
----
2025-08-10 15:00:00 true true
2025-08-10 16:00:00 true true

# Test 7: Check individual percentile calculations for hour 15:00 using time_bucket
query B
SELECT 
    approx_percentile(0.50, percentile_agg(duration)) / 1000000.0 BETWEEN 65 AND 85 AND
    approx_percentile(0.75, percentile_agg(duration)) / 1000000.0 BETWEEN 80 AND 95 AND
    approx_percentile(0.90, percentile_agg(duration)) / 1000000.0 BETWEEN 85 AND 95
    AS percentiles_in_range
FROM test_spans
WHERE project_id = 'test-project'
AND time_bucket('1 hour', timestamp) = '2025-08-10T15:00:00'
----
true

# Test 8: Check individual percentile calculations for hour 16:00 using time_bucket
query B
SELECT 
    approx_percentile(0.50, percentile_agg(duration)) / 1000000.0 BETWEEN 140 AND 160 AND
    approx_percentile(0.75, percentile_agg(duration)) / 1000000.0 BETWEEN 170 AND 210 AND
    approx_percentile(0.90, percentile_agg(duration)) / 1000000.0 BETWEEN 190 AND 210
    AS percentiles_in_range
FROM test_spans
WHERE project_id = 'test-project'
AND time_bucket('1 hour', timestamp) = '2025-08-10T16:00:00'
----
true

# Test 9: Complex GROUP BY with multiple dimensions
statement ok
INSERT INTO test_spans VALUES
('other-project', '2025-08-10T15:00:00Z', 25000000),   -- 25ms
('other-project', '2025-08-10T15:30:00Z', 35000000),   -- 35ms
('other-project', '2025-08-10T16:00:00Z', 45000000),   -- 45ms
('other-project', '2025-08-10T16:30:00Z', 55000000)    -- 55ms

# Test with ranges using time_bucket for hourly aggregation
query TTBB
SELECT 
    project_id,
    to_char(time_bucket('1 hour', timestamp), 'YYYY-MM-DD HH24:MI:SS') as hour,
    approx_percentile(0.5, percentile_agg(duration)) / 1000000.0 BETWEEN 
        CASE project_id 
            WHEN 'other-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 29 ELSE 49 END
            WHEN 'test-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 74 ELSE 149 END
        END AND
        CASE project_id 
            WHEN 'other-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 31 ELSE 51 END
            WHEN 'test-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 76 ELSE 151 END
        END as p50_ok,
    approx_percentile(0.95, percentile_agg(duration)) / 1000000.0 BETWEEN 
        CASE project_id 
            WHEN 'other-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 34 ELSE 54 END
            WHEN 'test-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 88 ELSE 194 END
        END AND
        CASE project_id 
            WHEN 'other-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 35 ELSE 55 END
            WHEN 'test-project' THEN CASE EXTRACT(HOUR FROM time_bucket('1 hour', timestamp)) WHEN 15 THEN 90 ELSE 199 END
        END as p95_ok
FROM test_spans
WHERE project_id IN ('test-project', 'other-project')
GROUP BY project_id, time_bucket('1 hour', timestamp)
ORDER BY project_id, hour
----
other-project 2025-08-10 15:00:00 true true
other-project 2025-08-10 16:00:00 true true
test-project 2025-08-10 15:00:00 true true
test-project 2025-08-10 16:00:00 true true

# Test 10: Test time_bucket with different intervals (30 minutes, 2 hours)
query TB
SELECT 
    to_char(time_bucket('30 minutes', timestamp), 'YYYY-MM-DD HH24:MI:SS') as half_hour_bucket,
    approx_percentile(0.5, percentile_agg(duration)) / 1000000.0 BETWEEN 25 AND 200 as median_ok
FROM test_spans
WHERE project_id = 'test-project'
GROUP BY time_bucket('30 minutes', timestamp)
ORDER BY half_hour_bucket
----
2025-08-10 15:00:00 true
2025-08-10 15:30:00 true
2025-08-10 16:00:00 true
2025-08-10 16:30:00 true

# Test time_bucket with 2 hour intervals
query TB
SELECT 
    to_char(time_bucket('2 hours', timestamp), 'YYYY-MM-DD HH24:MI:SS') as two_hour_bucket,
    approx_percentile(0.5, percentile_agg(duration)) / 1000000.0 BETWEEN 
        CASE EXTRACT(HOUR FROM time_bucket('2 hours', timestamp)) 
            WHEN 14 THEN 45 
            ELSE 95 
        END AND 
        CASE EXTRACT(HOUR FROM time_bucket('2 hours', timestamp)) 
            WHEN 14 THEN 65 
            ELSE 105 
        END as median_ok
FROM test_spans
WHERE project_id IN ('test-project', 'other-project')
GROUP BY time_bucket('2 hours', timestamp)
HAVING COUNT(*) > 1
ORDER BY two_hour_bucket
----
2025-08-10 14:00:00 true
2025-08-10 16:00:00 true

# Clean up
statement ok
DROP TABLE test_spans
